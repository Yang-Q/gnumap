#include "SNPScoredSeq.h"

#ifdef SNP_NW

//1. we currently expect this function to be called from sam2sgr.cpp but not from Driver.cpp since we want to separate gmp pileup from mapping step
//2. this phmm approach designs to use a general sam format but it will be great if it uses posterior prob from sam file generated by gnumap!
//3. todo: it only supports NW sam format. To support SW(soft clipped) sam format, gen_string should be given after removing all other unmapped parts which should be done from sam2sgr.cpp
//4. todo: for now, ins not yet supported yet!

void SNPScoredSeq::score(double denom, Genome &gen, unsigned int len, Read &read, map<unsigned long, unsigned int> &refMapLoc, double &denom_new, pthread_mutex_t &lock) {

	if(!positions.size())	//if there were no matches, just return.
		return;

	double total_score = log_align_score / denom;

	// we only need to compute this alignment string once because, while there may be many 
	// locations for each sequence, we're ensuring that the sequences are the exact same.

	bin_seq bs;

	string gen_string = sequence;
	string read_consensus;
	float** hmm_aligned;
	unsigned int genStrLen = gen_string.size();
	
	if(firstStrand == NEG_STRAND) {
		//fprintf(stderr,"Is on the negative strand! %s\n",__FILE__);
		// Copy it so we don't need to reverse it again
		float** rev_pwm = reverse_comp_cpy(read.pwm,read.length);
		Read rc(rev_pwm,read.length);
		rc.name = read.name;
		read_consensus = GetConsensus(rc);
		
		hmm_aligned = bs.pairHMM(rc, read_consensus, gen_string);
		
		// Clean up the copy
		for(unsigned int i=0; i<rc.length; i++) {
			delete[] rev_pwm[i];
		}
		delete[] rev_pwm;
	}
	else {
		read_consensus = GetConsensus(read);
		hmm_aligned = bs.pairHMM(read, read_consensus, gen_string);
	}

	// Need to create the reverse compliment as well
	float** hmm_aligned_rev = reverse_comp_cpy_phmm(hmm_aligned, genStrLen);

	//fprintf(stderr,"Aligning (size=%u) %s vs %s\n",positions.size(),read_consensus.c_str(),gen_string.c_str());
	
	set<pair<unsigned long,int> >::iterator sit;
	
	//we don't need positions_offset here since this position must be read from sam file which is already computed!
	MUTEX_LOCK(&lock);
	for(sit=positions.begin(); sit!=positions.end(); sit++) {
		// If it's the same strand as the first, we'll just add it to the genome normally.
		// Otherwise, we need to take the reverse-complement of the phmm sequence and add 
		// it to the genome that way
		if(sit->second == firstStrand) {
			for(unsigned int i=0; i<genStrLen; i++) {
				gen.AddScore( (*sit).first+i,total_score );
				gen.AddSeqScore((*sit).first+i,hmm_aligned[i], total_score);
			}
		}
		else {
			for(unsigned int i=0; i<genStrLen; i++) {
				gen.AddScore( (*sit).first+i,total_score );
				gen.AddSeqScore((*sit).first+i,hmm_aligned_rev[i], total_score);
			}
		}
	}
	MUTEX_UNLOCK(&lock);
	
	// Free HMM arrays
	freeHMMSequence(hmm_aligned,genStrLen);
	freeHMMSequence(hmm_aligned_rev,genStrLen);
}

#else
/* 
 *This is the version of SCORE that doesn't use a pHMM.  Just to test.
 */
void SNPScoredSeq::score(double denom, Genome &gen, unsigned int len, Read &read,map<unsigned long, unsigned int> &refMapLoc, double &denom_new, pthread_mutex_t &lock) {
	
	if(!positions.size())	//if there were no matches, just return.
		return;

	//we only need to compute this alignment string once because, while there may be many locations for each
	//sequence, we're ensuring that the sequences are the exact same.

	bin_seq bs;	// global one

	pair<string,string> mapped;
	string read_consensus;
	string aligned, rev_comp;
	string gen_string;
	
	int i;
	unsigned int ui, uj;
	int rL0 = read.length-1;
	
	int gL0 = sequence.size()-1;
	int genStart, genLast;

	double total_score = log_align_score / denom; //this will be used by call from sam2sgr only with gSAM2GMP = true
	
	if (align_mode==SW_ALIGN) { //SW DP ------------------------

		read_consensus = GetConsensus(read);
		gen_string = sequence;
		mapped = bs.smith_waterman_w_track(read, read_consensus, gen_string, align_score);//<--updated

	}
	
	else { // NW DP ----------------
		int sL0 = (int)ceil(((double)rL0+1.0)/4.0);
		int probeL = gMAX_GAP + sL0;

		//float** endRead_pwm = create_pwm(sL0+1);
		float** endRead_pwm = read_create_copy(read.pwm,0,sL0+1);
		Read endRead(endRead_pwm,sL0+1);
		endRead.name = read.name;

		// If it's on the revcomp strand
		read_consensus = GetConsensus(read);
		//need to find the beggining position of gen_string to map
		
		//note that sequence must be rev.com if this read was aligned to negative strand
		if (gSAM2GMP) {gen_string=sequence;}
		else{
			if (probeE1) {
				read_copy(endRead.pwm,read.pwm,0,sL0+1); // two indices
				bs.detect_nw_ends(endRead,sequence.substr(0,probeL),positions_offset,genLast,SEN_GEN_START);
			}
			else {positions_offset = 0;}

			if (probeE2) {
				read_copy(endRead.pwm,read.pwm,rL0-sL0,rL0); //two indices
				bs.detect_nw_ends(endRead,sequence.substr(gL0-probeL,probeL+1),genStart,genLast,SEN_GEN_LAST);
				genLast = gL0-probeL + genLast;
			}
			else {genLast = gL0;}
			gen_string = sequence.substr(positions_offset,genLast-positions_offset+1);
		}
			

		//fprintf(stderr,"Is on the negative strand! %s\n",__FILE__);
		mapped = bs.get_align_score_w_traceback2(read, read_consensus, gen_string, align_score);//<--updated


		// Clean up the copy of sensing probe
		for(i=0; i<=sL0; i++) {delete[] endRead_pwm[i];}
		delete[] endRead_pwm;

	}
	
	aligned = mapped.first;
	cigar2print = mapped.second; //<--updated
	
#ifdef DEBUG
	fprintf(stderr,"\ng:%s\na:%s\nr:%s\n", gen_string.c_str(),aligned.c_str(),read_consensus.c_str());
#endif

	log_align_score = exp(align_score); //<--updated
	
	set<pair<unsigned long,int> >::iterator sit;
		
	if (gSAM2GMP) {
		
		rev_comp = reverse_comp(aligned);
		
		//fprintf(stderr,"Aligning %s with %s, result %s\n",gen_string.c_str(),read_consensus.c_str(),aligned.c_str());
MUTEX_LOCK(&lock);
		for(sit=positions.begin(); sit!=positions.end(); sit++) {

			if(sit->second == firstStrand) {
				uj=0;
				for(ui=0; ui<aligned.size(); ui++) {
					if (aligned[ui]!='i') {//match or delete?
						gen.AddScore( (*sit).first+uj,total_score );
						gen.AddSeqScore((*sit).first+uj,total_score,g_gen_CONVERSION[(unsigned int)aligned[ui]]);
						uj++;
					}
				}
			}
			else {
				uj=0;
				for(ui=0; ui<rev_comp.size(); ui++) {
					if (aligned[ui]!='i') {//match or delete?
						gen.AddScore( (*sit).first+uj,total_score );
						gen.AddSeqScore((*sit).first+uj,total_score,g_gen_CONVERSION[(unsigned int)rev_comp[ui]]);
						uj++;
					}
				}
			}
		}
		MUTEX_UNLOCK(&lock);

	}
	else {
		//update overall mapping position which is sent from outcall
		for(sit=positions.begin(); sit!=positions.end(); sit++) {
			if (refMapLoc[(*sit).first+positions_offset] == 0){
				denom_new+=log_align_score;
			}
			refMapLoc[(*sit).first+positions_offset]++;
		}		
	}
}
#endif
